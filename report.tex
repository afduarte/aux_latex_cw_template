% #######################################
% ########### FILL THESE IN #############
% #######################################
\def\mytitle{Flickr Uploadr}
\def\mykeywords{Advanced, Web, Technologies, Python, Flask, Flickr, Scheduler }
\def\myauthor{Antero Duarte}
\def\contact{40211946@live.napier.ac.uk}
\def\mymodule{Advanced Web Technologies (SET09183)}
% #######################################
% #### YOU DON'T NEED TO TOUCH BELOW ####
% #######################################
\documentclass[10pt, a4paper]{article}
\usepackage[a4paper,outer=1.5cm,inner=1.5cm,top=1.75cm,bottom=1.5cm]{geometry}
\twocolumn
\usepackage{graphicx}
\graphicspath{{./images/}}
%colour our links, remove weird boxes
\usepackage[colorlinks,linkcolor={black},citecolor={blue!80!black},urlcolor={blue!80!black}]{hyperref}
%Stop indentation on new paragraphs
\usepackage[parfill]{parskip}
%% Arial-like font
\IfFileExists{uarial.sty}
{
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{uarial}
\renewcommand{\familydefault}{\sfdefault}
}{
\GenericError{}{Couldn't find Arial font}{ you may need to install 'nonfree' fonts on your system}{}
\usepackage{lmodern}
\renewcommand*\familydefault{\sfdefault}
}
%Napier logo top right
\usepackage{watermark}
%Lorem Ipusm dolor please don't leave any in you final report ;)
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}
%give us the Capital H that we all know and love
\usepackage{float}
%tone down the line spacing after section titles
\usepackage{titlesec}
%Cool maths printing
\usepackage{amsmath}
%PseudoCode
\usepackage{algorithm2e}
%URLS%
\usepackage{hyperref}

\usepackage{csquotes}

\titlespacing{\subsection}{0pt}{\parskip}{-3pt}
\titlespacing{\subsubsection}{0pt}{\parskip}{-\parskip}
\titlespacing{\paragraph}{0pt}{\parskip}{\parskip}
\newcommand{\figuremacro}[5]{
\begin{figure}[#1]
\centering
\includegraphics[width=#5\columnwidth]{#2}
\caption[#3]{\textbf{#3}#4}
\label{fig:#2}
\end{figure}
}

\lstset{
escapeinside={/*@}{@*/}, language=C++,
basicstyle=\fontsize{8.5}{12}\selectfont,
numbers=left,numbersep=2pt,xleftmargin=2pt,frame=tb,
columns=fullflexible,showstringspaces=false,tabsize=4,
keepspaces=true,showtabs=false,showspaces=false,
backgroundcolor=\color{white}, morekeywords={inline,public,
class,private,protected,struct},captionpos=t,lineskip=-0.4em,
aboveskip=10pt, extendedchars=true, breaklines=true,
prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
keywordstyle=\color[rgb]{0,0,1},
commentstyle=\color[rgb]{0.133,0.545,0.133},
stringstyle=\color[rgb]{0.627,0.126,0.941}
}

% Define JavaScript as a language for lstlistings
%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={const, let, undefined, try, async, await, typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]`,
morestring=[b]"
}

\lstset{
language=JavaScript,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
showstringspaces=false,
showspaces=false,
numbers=left,
numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b
}

% create a footref command that references footnotes as superscript text %
\newcommand{\footref}[1]{\textsuperscript{\ref{#1}}}

\thiswatermark{\centering \put(336.5,-38.0){\includegraphics[scale=0.8]{logo}} }
\title{\mytitle}
\author{\myauthor\hspace{1em}\\\contact\\Edinburgh Napier University\hspace{0.5em}-\hspace{0.5em}\mymodule}
\date{}
\hypersetup{pdfauthor=\myauthor,pdftitle=\mytitle,pdfkeywords=\mykeywords}
\sloppy
% #######################################
% ########### START FROM HERE ###########
% #######################################
\begin{document}
\maketitle
\begin{abstract}
        %Replace the lipsum command with actual text 
        Flickr Uploadr is an application that allows users of the photography oriented platform Flickr to schedule photos to be uploaded at a later date. The users connect their flickr account to the app and can schedule photos to be uploaded and can change the title, description and tags of a photo.
        \end{abstract}

        \textbf{Keywords -- }{\mykeywords}

        \section{Introduction}
        \paragraph{Flickr \cite{Flickr}}, like many social media platforms, prioritises content from users who post regularly. This means that the same user, with the same following and a comparable quality photo is more likely to get more exposure and better reception for a photo that is posted in the 10th day of a 10 day streak, than one posted on the first day.

        \figuremacro{h}{home}{Flickr Uploadr}{ - Home page}{1.0}

        This application, by allowing users to schedule posts for later days, allows people who see photography as a hobby to enjoy a higher level of exposure within the platform. For photography professionals, it allows them to batch edit photos and schedule them for upload and not have to worry about being consistent with their posts and focus more on the rest of their work.

        \subparagraph{Flickr Uploadr} uses the Flickr REST API \cite{Flickr_Services} to upload photos as the logged in user.
        It uses a microsevice-like architecture and decouples the frontend from the backend \cite{Microservices_and_SPAs_2017}.

        \section{Design}
        This web app was designed in line with modern standards and best practices.

        \figuremacro{h}{app}{Flickr Uploadr}{ - App home}{1.0}

        \subsection{Architectural Overview}
        \paragraph{The backend} uses python Flask \cite{Flask} for the web server activities, an embedded SQLite\cite{SQLite} database to store user information and uploading jobs \footnote{\label{ft:uploading_job} An uploading job is a photo and all of the associated settings needed to upload said photo to Flickr}.

        \paragraph{The frontend} uses Vue.js \cite{Vue.js}, a javascript framework. It is a framework that is increasing in popularity and is considered one of the top 3 javascript frontend SPA frameworks, alongside React.js \cite{React.js} and Angular.js \cite{Angular.js}.
        In my opinion, and the reason why I like it is that it stands exactly in the middle between the other two. Where Angular is too enterprise focused with little room for customisation in terms of code organisation and design patterns in favor of corporate-oriented standardisation, and React.js makes no assumptions and offers little in the way of suggesting best practice, leaving that for the developer to deal with.
        Vue.js offers a standardised way of organising code, by providing single-file components \cite{single_file_components}, which include markup, logic and presentation in the same file, but at the same time, it can be used in more complex applications, with state \cite{Vuex} and route \cite{Vue_Router} management or simpler applications as a substitute for older Document Object Model manipulation based solutions like jQuery \cite{jquery_vue}.


        \subsection{Database and data modelling}
        As mentioned before, the database is a SQLite disk persisted instance that is accessed from the code through the Peewee Object Relational Mapper \cite{peewee}. The database schema is as seen in figure \ref{fig:db}. 

        \figuremacro{h}{db}{Database Schema}{}{0.6}

        Figure \ref{fig:db} shows 2 main tables, user and job. Peewee recommends that auto-incrementing IDs are used as primary keys for the database tables, but since there is no canonical answer to this question \cite{primary_key_choosing}, I decided to go with what we learned in the 2nd year Database module, that when natural primary keys exist, they should be used in favor of surrogate keys.

        Although this is an advantage in terms of data design, it introduced a workaround, since peewee supports the opposing view.
        \begin{lstlisting}[label=lst:peewee_save, language = Python, caption = Peewee save function workaround]
        class BaseModel(Model):
    			# We override save because we use self managed primary keys, and peewee docs
    			# say that we must always call it with force_insert=True when that is the case
    			# So I'm expecting this to save countless hours of debugging
    			def save(self, *args, **kwargs):
    			    if "force_insert" not in kwargs:
    			        kwargs["force_insert"] = True
    			    return super(BaseModel, self).save(*args, **kwargs)
        \end{lstlisting}
        The code excerpt \ref{lst:peewee_save} shows the workaround for peewee's default save function. As explained in the documentation \cite{peewee_pkeys}, self managed primary keys need the argument \texttt{force\_insert} to be set to \texttt{True} on every save.


        \subsection{Authentication/Authorisation}

        This application extends Flickr, which means users need a Flickr account to use the application. Flickr provides an Oauth \cite{oauth} server as part of their API \cite{Flickr_oauth}, which means that the amount of data this application needs to keep about a user is minimal. It also takes the pressure away from this app to manage users and passwords.
        The application links a user account to a Flickr \texttt{user\_nsid}, which is Flickr's unique identifier for users. It also stores an Oauth Token, so it can upload photos as the user when scheduled, even if the user is offline. Although it is generally discouraged to store access tokens, it is the only option when scheduling activities on behalf of the user.

        \subsection{Decoupled frontend}
        As mentioned before, this application uses Vue.js to provide a modern, feature-rich interface that connects to the server using a RESTful API \cite{restful_api}. Vue.js is a reactive library, which means that changes to the application state will trigger components that receive the state to re-render. In practice this means that a developer does not have to manually listen to events in the DOM\footnote{\label{ft:DOM}Document Object Model}, to trigger changes to the DOM\footref{ft:DOM}. This enables faster development and less time debugging/dealing with DOM\footref{ft:DOM} quirks.

        \subsection{Application functionality}
        Upon logging in, a user can upload images to the server by using the file drop box, provided by \texttt{vue-dropzone}\cite{vue-dropzone}, which is a plugin that implements Dropzone.js as a Vue component. Uploaded images automatically generate a job ID (v4 UUID\cite{itu_uuid}) and the job fields are set to their defaults (\texttt{title='name\_of\_the\_uploaded\_file'}, \texttt{description=''}, \texttt{tags=''}, \texttt{upload\_time=current\_time + 1 day}). After creating, a job's status is set to \texttt{WAITING}, meaning it is on the queue to be processed shortly after \texttt{current\_time > job.upload\_time} (See figure \ref{fig:waiting-jobs}).\\
        Shortly after, because there are no guarantees that a job will run exactly on the specified time, for example, if there's a queue of jobs all set to run at 5pm, they will run in the order they come from the database, presumably, row creation time, which essentially means first come, first served.

        \figuremacro{h}{waiting-jobs}{Jobs waiting to be processed}{}{1.0}

        A job can be edited, so a user can update the photo's title on Flickr, the photo's description on Flickr, the photo's tags on Flickr, and the uploading time (See figure \ref{fig:editing-job}).

        \figuremacro{h}{editing-job}{Jobs editing form}{}{1.0}

        The uploading time is displayed in the form of a calendar, where past dates are blocked (See figure \ref{fig:time-picker}). As shown in the screenshot, taken on the 23rd, days 23 and before are blocked.
        The reasoning behind blocking the 23rd as well stems from a belief that people using a scheduler should not be putting pressure on the server for immediate/almost immediate uploads.

        \figuremacro{h}{time-picker}{Calendar}{}{1.0}

        This means that a user posting a job for now + 5 minutes is essentially shifting the effort on to the server, rather than waiting 5 minutes and posting the photo manually on Flickr.
        This is not a hard constraint, and is not checked on the server side, but by introducing an element of friction on the UI \cite{ui_friction}, it discourages users from doing it\footnote{\label{ft:friction} In fact, only a user with knowledge of programming or at least HTTP/REST could manipulate the request being sent to set a photo to be uploaded on the same day}. The server will not allow past dates though, validating input to check if \texttt{upload\_time < now}.

        Once the upload time comes for a photo, it is uploaded to flickr and it's job status updated to \texttt{COMPLETED}. There are also intermediate stages between \texttt{WAITING} and \texttt{COMPLETED}. During the upload a job is marked as \texttt{UPLOADING}, and if there's an error, the job is marked as \texttt{ERRORED}.

				\figuremacro{h}{completed-jobs}{Completed Jobs}{}{1.0}        

        \subsection{URL Structure}
        \subsubsection{URL Map}
        Since this application is based on a REST API, the URL structure is quite simple, as can be seen in Figure \ref{fig:url-map}. The only page generated server-side is the welcome page. All other routes are either redirects in or out of the oauth flow, or API endpoints that serve data for the Vue frontend to render.


        \figuremacro{h}{url-map}{URL map}{}{1.0}


        \subsubsection{Navigation map}
        As for navigation, the application presents the map in figure \ref{fig:nav-map}.

        \figuremacro{h}{nav-map}{Navigation map}{}{1.0}


        \subparagraph{Note} the navigation around the Login flow, which as per the oauth spec \cite{oauth}, sends a user to Flickr to authenticate (figure \ref{fig:flickr-login}\footnote{\label{ft:yahoo} At the time of writing, flickr was in the process of transitioning from being owned by Yahoo and using Yahoo's login system, which is why the flickr login screen is a yahoo login screen.}), then send the user to a consent page (figure \ref{fig:flickr-consent}) which authorises the application to perform activities on behalf of the user, and then back to the application, which receives the necessary parameters to request an access token via url query parameters, and finally redirects the user to the application home page, where the application already has access to user data, as seen before on figure \ref{fig:app}, where the user's Flickr full name is shown.

        \figuremacro{h}{flickr-login}{Oauth flow}{ - Flickr/yahoo login\footref{ft:yahoo}}{1.0}

        \figuremacro{h}{flickr-consent}{Oauth flow}{ - Flickr consent page}{1.0}

        \section{Enhancements}
        \label{sec:enhancements}
        \blockquote{If it ain't broke, don't fix it. Do improve it though...}

        There are several things I would have done if I had more time to develop this project. Although the initial idea/functionality is all covered, a few more elements would greatly improve this application. 

        \subsection{Tiered user system}	
        As is, all users are the same to the application, but during development, I had the idea to create a tiered user system, where different usage tiers would have different privileges. For example, there is no limit to the amount of photos a user can upload, but to make this application feasible and free to use, there would have to be restrictions on the amount of images a user can post so the disk usage on the server doesn't grow endlessly. One of the user tiers, could have the user pay for unlimited or a higher cap on storage. This would mean the paid users would be paying for the server/hosting, while free users could still enjoy some of the benefits of the system.\\
        Introducing a cap on storage would mean that the application would have to keep track of how much disk space a user is currently using, which it doesn't at the time of writing.

        \subsection{Plugable storage back-ends}
        An alternative (or possibly something that could run alongside) the paid tiered user model is to have multiple storage backends that could be connected using SDKs and APIs. It might also bring piece of mind for more security aware users who don't want to trust their images to some random server on the internet.
        Services like Dropbox \cite{dropbox}, Amazon S3 \cite{s3} and Google Drive \cite{gdrive} offer APIs to store and retrieve files. If the application offered an alternative to disk storage, the running costs could greatly be reduced, meaning the service could stay free of charge, case the user decided to store their photos on their own storage. Then Flickr Uploadr acts merely as a vehicle between a user's personal storage and their Flickr account. 

        \subsection{Sneaky Flickr Uploadr tag}
        Another idea to raise funds to run the application was to introduce a \texttt{Flickr Uploadr} tag on every photo uploaded through the application. Users would then be given an option to donate towards the running costs of the server in exchange for not having this tag placed on their photos. This is obviously something that might slightly annoy users and a tag is easily removed by a user on Flickr, but the simple fact that a prompt shows up, might raise awareness that even though the service is free, it incurs in development, maintenance and hosting costs for the developer, and donating something towards the running costs could help the service stay up.
        
        \subsection{Microservices}
        While this application follows some rules of microservice-oriented architecture, it could be further broken down, which would mean it would be easier to scale. For example both the thumbnail generation and job uploading functions could be implemented using a message queue worker pattern \cite{message_queue_pattern}, making the bulk of the application way more scalable and leaving only a simple static HTTP server to serve the frontend and a minimal Web Server to turn API calls into messages on the queue and retrieve completed jobs. This could greatly improve the performance of the application on scale, and would mean that more users could be using the application at the same time.

        \subsection{Smarter scheduling}
        Right now, there is a serious risk that everyone schedules photos to be posted at 9am on the 21st of December to mark the start of the winter solstice, and with enough users, this could just overload the server and severely delay or even error some photos being posted. With a smarter scheduling algorithm, some photo uploads could be delayed or anticipated to reduce the stress on the server and the network at that specific time. Again, this could be a feature of donating users, to schedule an exact time, and give free users a window of 30 minutes/1 hour when their photo would be posted

        \subsection{Deeper connection to flickr}
        This application could offer a much bigger connection to flickr. For example, as a user posts photos, the application could track which times are better to post photos, by measuring the number of views/likes that photos get when posted at different times. This could go even further and compare a users' average like/view gain/loss to other users and suggest better times to upload photos, based on the photo's reception.

        \section{Critical evaluation}
        This project is not exactly what I imagined. While certainly the functionality is all there, there are a lot of rough edges. The fact that I chose to build the frontend as a different codebase might have penalised my work in other parts of the project. Since I had to deal with 2 codebases, I feel that some of the work might feel rather unpolished.
        
        \subsection{The API}
        While functional for adding/editing/getting, I feel like the API exposed from this project could have been a bit more fleshed out. There are a few inconsistencies in field names, field types (e.g: uploading time is a string when GETing, but must be a Unix timestamp integer when PUTing). This was a problem I started having when trying to validate on the server side. Essentially it means that I should have planned for a lack of a canonical standard date format, hence Python and Javascript have to translate dates for each other.
        There are also missing features that are quite obvious, not hard to implement and I just ran out of time, like a \texttt{DELETE /job/<id>} endpoint.

        \subsection{The frontend}
        Although I'm happy with the code quality in the frontend codebase, I feel like the design feels a bit unpolished. It is not bad, but there are a few elements that seem odd and out of place. I had a few ideas, and asked for help from a proper designer, but like many other things in this project, in the end, just ran out of time. One idea that could turn the frontend upside down was to present uploading jobs in a timeline, rather than just listing them. This could be visually appealing and if done correctly, very functional, as this application hangs around 2 things: photography and time.

        \subsection{Code quality}
        I pride myself in striving for quality code. I always try to code for myself in 2 years, having looked at 2 year old code and cringing at how bad it used to be. I obviously don't know everything and expect to still cringe in 2 years time. The point being, there are things about this project that I am not happy about in terms of code quality. For example, when using the threading module and running the job thread, I think it should have been implemented in a way that the job thread knows when the main application thread is stopped, because when sending a SIGINT to the main program, the threading modules throws an Exception from the join function.

        \subsection{The good bits}
        Ultimately, I made it work. The application is a proof of concept, but it works. I will be using it, personally while I rebuild it in a way I feel I could present it to the world.
        The good side of having decoupled the frontend is that I can completely rewrite the backend while using the same frontend, and vice-versa.

        \section{Personal Evaluation}
        As evidenced through a very long enhancements section (section \ref{sec:enhancements}), and a complete critical evaluation, there are a lot of things I wish I could have done with this project, so in a way it feels incomplete.
        But if I must be honest with myself, I should look at the complexities and intricacies of this project.\\
        Apart from knowing the platform I was interfacing with really well (which admitedly I already did, being a user), I had to understand how the API works, I had to find the right libraries for the project, gain a deeper understanding of the Oauth flow, and then re-learn it since Flickr doesn't implement it exactly like the spec, only to then realise there is a library that does it for me, better than I was doing it at that point. Ups and downs, failures and successes, but such is the life of a developer.

        \subsection{The veredict}
        In the end I am happy, but not satisfied with the current status of the project and hope to be able to continue work on it. I plan to either rework the parts that I'm not very happy with, or actually re-design the whole application taking into consideration everything mentioned before in the enhancements section. One interesting idea is to try to implement the project as a serverless application in a FaaS (function as a service) platform.
        Ultimately this project shows a lot of promise, but because of some aspects, it doesn't completely deliver. I am commited to keep working on it and make it a full-fledged application.

        \bibliographystyle{ieeetr}
        \bibliography{references}

        \end{document}
